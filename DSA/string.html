<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <link rel="stylesheet" href="../style.css">
     <link rel="stylesheet" href="code-style.css">
     <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/brown-paper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <title>String</title>
</head>
<body>
    <p class="question">Removes the outermost parentheses</p>
    <p style="margin: 0px;">This method removes the outermost parentheses from each group of balanced parentheses in the input string. It uses a variable called <span class="code">depth</span> to keep track of how deep we are inside nested parentheses.<br>As we go through the string:</p>
    <ul style="margin: 0px;">
        <li>When we see <span class="code">&#39;(&#39;</span>, we increase the depth. If we are already inside (<span class="code">depth > 0</span>), we add it to the result because it's not the outermost opening bracket.</li>
        <li>When we see <span class="code">&#39;)&#39;</span>, we first decrease the depth. If we are still inside (<span class="code">depth != 0</span>), we add it to the result because it's not the outermost closing bracket.</li>
    </ul>
    <p style="margin: 0px;">This way, we skip the first and last parentheses of every primitive group, effectively removing their outer layer.</p>
    <pre style="margin: 0px;"><code class="language-java" style="border-radius: 10px;">public static String removeOuterParentheses(String input) {
    
    StringBuilder result = new StringBuilder();
    int depth = 0;  // Tracks current level of nesting

    for (char c : input.toCharArray()) {
        
        if (c == &#39;(&#39;) {
            depth++; // Going deeper into nesting
            if (depth &gt; 1) {
                result.append(c); // Not the outermost &#39;(&#39;, so keep it
            }
        } else if (c == &#39;)&#39;) {
            depth--; // Coming out of nesting
            if (depth != 0) {
                result.append(c);
            }
        }

    }

    return result.toString();
}

     * * * * * * Suggested Unit Tests * * * * * *
assert removeOuterParentheses("(()())(())").equals("()()()");
assert removeOuterParentheses("()()").equals("");
assert removeOuterParentheses("((()()))").equals("(()())");</code></pre>
    <p style="margin-top: 2px; margin-bottom: 5px;">We use <span class="code">StringBuilder</span> to build the result because it is much faster than using a regular String when repeatedly adding characters. Strings in Java are immutable, so every time you use <span class="code">+</span> with a String, a new object is created, which is slow and uses more memory. StringBuilder avoids this by modifying the existing object, making it more efficient.</p>
    <p style="margin: 0px;">We use <span class="code">StringBuilder</span> instead of <span class="code">StringBuffer</span> because we are not dealing with multiple threads here — StringBuilder is faster in single-threaded code since it doesn't have the overhead of thread safety.</p>
    <p style="margin-top: 5px; margin-bottom: 0px;">The code goes through the string only once, so it works fast (O(n) time), and it doesn't use any extra space except for the result (O(n) space).</p>
    <br>
    <p class="question">Check if two strings have a common substring</p>
    <p style="margin: 0px;">The method checkCommonSubstring determines whether two strings share at least one common character. It begins by creating a <span class="code">HashSet</span> to store all characters from the first string, s1. As it loops through each character in s1, it adds them to the set using the <span class="code">add()</span> method. After this, it iterates through each character in the second string, s2, and uses the <span class="code">contains()</span> method to check if the character exists in the set. If a common character is found, the method returns true immediately. If no match is found after checking the entire second string, it returns false.</p>
    <pre style="margin-top: 5px 0px 0px 0px;"><code class="language-java" style="border-radius: 10px;">public static boolean checkCommonSubstring(String s1, String s2) {
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();

    for (char c : s1.toCharArray()) {
        set.add(c); // Store all characters of s1
    }

    for (char c : s2.toCharArray()) {
        if (set.contains(c)) {
            return true; // Common character found
        }
    }

    return false; // No common character found
}

    * * * * * * Suggested Unit Tests * * * * * *
assert checkCommonSubstring("hello", "world") == true;
assert checkCommonSubstring("123", "456") == false;
assert checkCommonSubstring("abc", "xyz") == false;</code></pre>
        <p style="margin-top: 2px; margin-bottom: 5px;">In terms of performance, the <span class="code">add()</span> and <span class="code">contains()</span> methods of HashSet generally operate in constant time, <b style="font-size: 95%;">O(1)</b>, on average. This efficiency comes from the underlying hash table implementation, which allows for direct indexing based on the hash of the elements. However, in the worst-case scenario—when too many hash collisions occur—these operations can degrade to <b style="font-size: 95%;">O(n)</b> time. This happens when multiple elements are mapped to the same hash bucket, turning the underlying data structure for that bucket into a linked list or a balanced tree, depending on the Java version. Although such cases are rare due to good hashing strategies, it is still important to be aware that the worst-case performance of both add() and contains() is O(n).</p>
        <p style="margin-top: 0px;">So, in typical situations, building the set from the first string takes <b style="font-size: 95%;">O(n)</b> time, and checking each character in the second string also takes <b style="font-size: 95%;">O(m)</b> time, leading to an average-case total time complexity of <b style="font-size: 95%;">O(n + m)</b>. But in the worst case, due to excessive collisions, the time complexity can degrade to <b style="font-size: 95%;">O(n × m)</b>. The space complexity remains <b style="font-size: 95%;">O(n)</b> since up to all characters of s1 may be stored in the set.</p>
        <br>
        <p class="question">Find the First Non-Repeated Character in a String.</p>
        <p style="margin: 5px 0px 0px 0px;">To approach this, I first iterate over the characters of the string and track their frequency using a <span class="code" style="background-color: #e4e4e4;">LinkedHashMap</span>, which preserves the order in which characters appear. While inserting each character, I use the merge method to simplify the logic: if the character is already present, its count is incremented; otherwise, it is added with an initial count of 1. After building the frequency map, I stream through its entries to find the first character whose count is 1. Since the map maintains insertion order, this guarantees the first non-repeating character is selected correctly.</p>
        <pre><code class="language-java" style="border-radius: 10px;">public static Character getNonRepeatingChar(String input) {
    Map&lt;Character, Integer&gt; frequencyMap = new LinkedHashMap&lt;&gt;();

    for (char c : input.toCharArray()) {
        frequencyMap.merge(c, 1, (oldValue, newValue) -&gt; oldValue + newValue);
    }

    return frequencyMap.entrySet()
            .stream()
            .filter(entrySet -&gt; entrySet.getValue() == 1)
            .map(entrySet -&gt; entrySet.getKey())
            .findFirst().orElse(null);
}

    * * * * * * Tests * * * * * *
getNonRepeatingChar("aabbcddde") // → 'c'
getNonRepeatingChar("aee")       // → 'a'
</code></pre>
<p style="margin-top: 0px;">The time complexity of this approach is <b style="font-size: 95%;">O(n)</b>, where <q>n</q> is the length of the input string. This comes from two passes over the input — one to build the map and another to scan for the result. The space complexity is <b style="font-size: 95%;">O(k)</b>, where <q>k</q> is the number of unique characters. In the worst case, k can be up to 26 for lowercase English letters, or 128/256 for full ASCII.</p>
<p style="margin-bottom: 0px;">If the input is constrained to lowercase English letters only, I optimize further by replacing the map with a fixed-size integer array of size 26. Each character's frequency is updated using its offset from 'a' as the index. This eliminates the overhead of object allocation and hashing. After populating the array, I again iterate over the string to find the first character with frequency 1. Here's the optimized version:</p>
<pre><code class="language-java" style="border-radius: 10px;">public static Character getNonRepeatingChar(String input) {
    int[] freq = new int[26];
    for (char c : input.toCharArray()) {
        freq[c - &#39;a&#39;]++;
    }
    for (char c : input.toCharArray()) {
        if (freq[c - &#39;a&#39;] == 1) {
            return c;
        }
    }
    return null;
}</code></pre>
<p style="margin-top: 0px;">This version still has <b style="font-size: 95%;">O(n)</b> time complexity but reduces the space complexity to <b style="font-size: 95%;">O(1)</b>, since the array size is constant and independent of input length. This is the preferred approach when character constraints are known and tight.</p>

<script>
        hljs.highlightAll(); 
    </script>
    <script>
        function copyToClipboard() {
          const text = document.getElementById("command").innerText;
          navigator.clipboard.writeText(text).then(() => {
            console.log("Copied!");
          }).catch(err => {
            console.error("Failed to copy: ", err);
          });
        }
    </script>
</body>
</html>