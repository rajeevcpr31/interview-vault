<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <title>techQA questions</title>
    <style>
        .container {
            display: flex;
            justify-content: space-between;
        }
        .code-block {
            width: 49%;
            border-radius: 5px;
            overflow-x: auto;
            margin: 8px 0px;
        }
    </style>
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/brown-paper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <p class="question">What is graphQL APIs and how it differs from REST APIs?</p>
    <p class="answer">GraphQL is a schema-based API style where the client decides exactly what data it wants and in what shape it wants it. Instead of exposing many URLs like REST, a GraphQL server exposes a single endpoint. The client sends a query that lists all the fields it needs, and the server returns only those fields. The GraphQL schema defines all types and fields available, acting like a shared contract between frontend and backend. Each field in the schema is resolved by a function called a resolver, which fetches data from databases or microservices.<br>GraphQL provides three main operations. A query is used to fetch data and works like a GET in REST, except the client can choose the exact fields to fetch. A mutation is used to modify data—similar to POST/PUT/DELETE in REST—but again, the client controls the returned fields. A subscription is used for real-time updates, allowing the server to push data to the client whenever something changes, which is harder to achieve with REST without extra protocols.<br>GraphQL differs from REST mainly in how data is fetched. REST organizes APIs around resource-based URLs such as <span style="background-color: aliceblue;">/users</span> or <span style="background-color: aliceblue;">/orders/{id}</span>, and each endpoint returns a fixed response. If the client needs more or different data, it often needs multiple calls or ends up downloading unnecessary fields. GraphQL avoids this by letting the client combine everything it needs in one request and ask for only the required fields. This solves the common problems of over-fetching and under-fetching.<br>GraphQL is especially helpful when clients have very different data needs. Mobile apps can reduce bandwidth by fetching only tiny slices of data. Dashboards or modern frontends can request complex nested data in one go. In microservice architectures, a GraphQL gateway can collect data from many services and return a unified response, so clients don't need to know about the internal service structure.<br>There are challenges too. Without careful design, GraphQL resolvers can accidentally cause N+1 problems where the server makes too many backend calls. Tools like DataLoader help batch and cache requests to prevent this. Caching is more complex than REST because all GraphQL requests hit one endpoint and their shapes vary, which makes traditional HTTP caching less useful. Authorization often must be handled at field level rather than endpoint level, which requires more careful design. GraphQL queries also need limits because clients can send deeply nested or expensive queries; persisted queries, depth limits, and cost rules help control this. The good part is that GraphQL schema evolution is easy: you can add new fields without breaking existing clients, and you rarely need versioning.<br/>REST still works better when your data is simple, resource-based, easy to cache, and when you want full advantage of HTTP features. It's predictable, easy to reason about, and often easier to operate. GraphQL is the better choice when the client needs flexibility, when you want to avoid multiple round trips, or when your backend consists of many microservices that need to be combined behind one API. 
    </p>

    <p class="question">Explain @Transactional in spring boot</p>
    <p class="answer"><span style="background-color: aliceblue;">@Transactional</span> defines a transaction boundary around a method. Everything inside that method forms one atomic unit of work, meaning all operations commit together or all roll back together. Spring manages this automatically by starting a transaction when the method begins and ending it when the method finishes. Two attributes&mdash;propagation and isolation&mdash;control how transactions behave when methods call each other and how concurrent transactions view data.<br><b>Propagation</b><br>Propagation determines what Spring should do when a transactional method is called from another method.<br>Let's use this example: Suppose <span style="background-color: ghostwhite;">MethodA</span> performs some database write operation (say it: dbA operation). Inside MethodA, you call MethodB, and MethodB performs a database write operation (say it dbB operation). During its execution, MethodB throws an exception. Depending on the propagation setting, Spring decides whether MethodB should join MethodA's transaction, start its own, or avoid transactions altogether. This choice determines whether dbA's changes, dbB's changes, or both get committed or rolled back.<br>Now each propagation behavior works like this:
    <ul style="margin: 0px;">
        <li><b style="font-size: 93%;">REQUIRED:</b> If MethodA has a transaction, MethodB joins it and both dbA and dbB roll back when MethodB throws. If MethodA has no transaction, MethodB creates one; dbB rolls back on exception, while dbA remains committed because it was autocommitted.</li>
        <li><b style="font-size: 93%;">SUPPORTS:</b> If MethodA has a transaction, MethodB joins and both roll back. If MethodA is non-transactional, MethodB also runs without one and both dbA and dbB changes stay committed because there is no transaction to roll back.</li>
        <li><b style="font-size: 93%;">MANDATORY:</b> MethodA must already have an active transaction. If MethodA has one, MethodB joins and both roll back on exception. If MethodA has no transaction, Spring throws IllegalTransactionStateException immediately before executing MethodB.</li>
        <li><b>REQUIRES_NEW:</b> MethodB always creates its own new transaction. If MethodA had one, it is suspended. MethodB rolls back dbB, but MethodA can still commit dbA normally.</li>
        <li><b style="font-size: 93%;">NOT_SUPPORTED:</b> If MethodA has a transaction, it is suspended. MethodB runs without a transaction and dbB changes are usually autocommitted even if an exception occurs. MethodA's transaction resumes later to commit or roll back dbA independently.</li>
        <li><b style="font-size: 93%;">NEVER:</b> MethodB must not run within a transaction. If MethodA has an active transaction, Spring throws IllegalTransactionStateException before running MethodB. If MethodA is non-transactional, MethodB runs without a transaction and dbB stays committed.</li>
        <li><b style="font-size: 93%;">NESTED:</b> MethodB runs inside a savepoint of MethodA's transaction. If MethodB throws, only the dbB changes roll back to the savepoint while dbA remains untouched. If MethodA later fails, everything rolls back including MethodB's rolled-back work.</li>
    </ul>
    <b>Isolation</b><br>Isolation defines what your transaction can see when other transactions read or write the same data concurrently.<br>
    Again, imagine MethodA and MethodB running at the same time, but now focus on reading/writing interactions. MethodA might read some data from dbA table while MethodB updates or inserts data in dbA table at the same time. Depending on the isolation level, MethodA may or may not see MethodB's changes, and it may or may not see new rows created by MethodB during its own transaction.<br>Each isolation level behaves like this:
    <ul style="margin: 0px;">
        <li><b style="font-size: 93%;">DEFAULT:</b> Uses the database's default isolation setting, usually READ_COMMITTED.</li>
        <li><b style="font-size: 93%;">READ_UNCOMMITTED:</b> MethodA can see MethodB's uncommitted writes. Dirty reads are possible, making this the least safe.</li>
        <li><b style="font-size: 93%;">READ_COMMITTED:</b> MethodA sees MethodB's changes only after MethodB commits. Prevents dirty reads but allows non-repeatable reads.</li>
        <li><b style="font-size: 93%;">REPEATABLE_READ:</b> Once MethodA reads a row, it continues to see the same version of that row even if MethodB commits updates later. This prevents dirty reads and non-repeatable reads. However, phantom reads can still occur. A phantom read means MethodA runs a query twice and, on the second run, sees newly inserted rows that match the same query criteria, even though existing rows remain stable.</li>
        <li><b style="font-size: 93%;">SERIALIZABLE:</b> Strictest isolation. MethodA and MethodB behave as if executed one after another. Prevents dirty reads, non-repeatable reads, and phantom reads, but reduces concurrency and may cause more locking or retries.</li>
    </ul>
    </p>
    <p class="question">Why volatile is not enough to make an operation thread safe in java?</p>
    <p class="answer">volatile in Java guarantees visibility, not atomicity, and that difference is exactly why volatile alone cannot make most operations thread-safe.<br>When you mark a variable as volatile, you ensure that whenever one thread writes to it, other threads immediately see the updated value. The value is always read from and written to main memory, not CPU caches, so threads don't work on stale copies. But this visibility guarantee does not mean the whole operation involving that variable is safe. Most real operations require more than just reading or writing a single value—they involve multiple steps, and that's where volatile breaks down.<br>A non-atomic operation like count++ is actually three separate actions: read the current value, add one, and write the new value back. Even if count is volatile, two threads can read the same value at the same time, both compute the same result, and both write back the same value. The <q>lost update</q> problem still occurs because volatile does not protect the critical section. The visibility rule only ensures the read and write hit main memory, but it does not ensure that the sequence of multiple steps happens as one indivisible unit.<br>Thread safety usually requires atomicity, mutual exclusion, or coordination. Operations like incrementing a counter, modifying collections, updating shared state, or checking-then-acting patterns need some form of locking or atomic classes because they require the entire sequence to execute without interference. synchronized or ReentrantLock ensures only one thread can perform the sequence at a time. Atomic classes like AtomicInteger use low-level CAS instructions to make multi-step updates act like a single atomic operation.</p>
    <p class="question">Difference between CopyOnWriteArrayList and Collections.synchronizedList(...)</p>
    <p class="answer">Collections.synchronizedList(list) wraps a normal List and synchronizes every operation using a single lock. This means every read and write acquires the same monitor lock. The benefit is that all operations are thread-safe, and modifications behave just like a normal list. But the downside is that heavy contention builds up under concurrent access. Multiple threads cannot read the list at the same time; they must take turns, which limits scalability. Iteration requires manual synchronization on the list to avoid ConcurrentModificationException. This approach is best when you have frequent writes and the list size is moderate, because modifications remain efficient and inexpensive.<br>CopyOnWriteArrayList takes a completely different approach. Instead of locking for reads, it allows concurrent readers to access the underlying array without locking at all. When a write operation occurs—like add, set, or remove—the list creates a new copy of the entire backing array, applies the modification, and replaces the reference. Reads are fast and never blocked, iteration never throws modification exceptions, and snapshots remain consistent. The trade-off is that writes are extremely expensive because copying the whole array is O(n) every time. This makes it a great fit for read-heavy workloads with very infrequent writes, especially when thread-safe iteration is important.<br>If your workload has many readers and very few updates, CopyOnWriteArrayList offers excellent scalability and nearly lock-free behavior for reads. You avoid locking overhead and get safe, consistent iterators. If your workload has frequent writes, or if the list is large, synchronizedList is a better choice because it doesn't require copying the entire underlying data structure on each modification. You pay for lock contention on reads, but writes remain efficient and predictable. Thus, the right choice depends on whether your system is dominated by reads or writes and how large you expect the list to grow.</p>
    <p class="question">What is <span style="background-color: whitesmoke;">@SpringBootApplication</span> annotation?</p>
    <p class="answer">In a Spring Boot application, the class with the main method is usually annotated with <span style="background-color: #e4e4e4;">@SpringBootApplication</span> because this single annotation activates three core Spring features at once: configuration, component scanning, and auto-configuration. It is essentially a convenience annotation that replaces <span style="background-color: aliceblue;">@Configuration</span>, <span style="background-color: aliceblue;">@EnableAutoConfiguration</span>, and <span style="background-color: aliceblue;">@ComponentScan</span> on the same class.<br>When Spring Boot starts, it uses the class annotated with <span style="background-color: aliceblue;">@SpringBootApplication</span> as the entry point for building the application context. Because of <span style="background-color: aliceblue;">@Configuration</span>, the class is treated as a source of bean definitions. Because of <span style="background-color: aliceblue;">@ComponentScan</span>, Spring automatically scans the package of that class and all its sub-packages for components like controllers, services, repositories, filters, and any other Spring-managed beans. Because of <span style="background-color: aliceblue;">@EnableAutoConfiguration</span>, Spring Boot activates its opinionated auto-configuration mechanism that attempts to configure beans for you based on what dependencies are on the classpath. For example, if Spring Web is present, it configures DispatcherServlet; if Spring Data JPA is present, it sets up EntityManagerFactory, DataSource, and Hibernate defaults.<br>The main class typically gets this annotation because it defines the root package for component scanning and auto-configuration. Putting this annotation on a class in some random package can change the scanning boundaries, which might make Spring fail to detect your components. Keeping it on the main class establishes a predictable base package structure.<br>If you remove @SpringBootApplication entirely, Spring Boot stops behaving like a Boot application. The application still runs the main method, but Spring won't create the application context as you expect. Without @Configuration, the class is no longer recognized as a source of beans. Without @ComponentScan, it won't pick up annotated components automatically, so controllers won't register, services won't be created, and repository interfaces won't be instantiated. Without @EnableAutoConfiguration, none of Spring Boot's auto-configured beans will load, so even fundamental infrastructure like the web server, DispatcherServlet, JSON handling, or database configurations will be missing.<br/>In practice, removing the annotation usually results in a startup failure because Spring has nothing configured: no embedded server, no handler mappings, no datasource. If you manually add @Configuration but forget @EnableAutoConfiguration, the app may start but behave like plain Spring, requiring you to configure everything yourself. If you add @ComponentScan manually but miss the correct base package, half your beans may not load. This is why interviewers often ask what @SpringBootApplication does internally: understanding it demonstrates that you know how Boot's conventions simplify configuration, what happens behind the scenes, and how to override or customize it if needed.<br/>A common follow-up question is whether you can replace @SpringBootApplication with the three individual annotations. You can, and the behavior is the same. Another question is what happens if the main class is placed in a nested package. Component scanning is package-based, so if your main class sits inside a deeply nested package, higher-level packages won't be scanned unless you explicitly set scanBasePackages. Interviewers also check whether you understand how auto-configuration loads. It works through spring.factories or the new AutoConfiguration import mechanism which registers configuration classes conditionally based on classpath or environment checks. The @SpringBootApplication annotation triggers this whole mechanism.<br/>So the annotation itself doesn't make the application run; it simply activates the entire Spring Boot startup model. Removing it reduces your app to a plain Java program with almost none of the convenience and infrastructure that makes Boot attractive.</p>
    <p class="question">What happens you call <span style="background-color: aliceblue;">SpringApplication.run(DemoApplication.class, args)</span> method?</p>
    <p class="answer">When you call <span style="background-color: #e4e4e4;">SpringApplication.run(DemoApplication.class, args)</span>, you are telling Spring Boot to start your entire application. This one line begins the full startup process. Spring Boot first records the start time so it can later show how long the application took to start. Then it prepares the environment by reading settings from application.properties or YAML files, system variables, and command-line arguments. At this early stage, it also loads and displays the banner from banner.txt if one exists.<br>After the environment is ready, Spring Boot creates the ApplicationContext, which is basically the container that manages all your Spring beans. Once the context is created, Spring Boot begins scanning your project for classes annotated with things like <span style="background-color: aliceblue;">@Component</span>, <span style="background-color: aliceblue;">@Service</span>, <span style="background-color: aliceblue;">@Repository</span>, <span style="background-color: aliceblue;">@Controller</span>, and <span style="background-color: aliceblue;">@Configuration</span> so that it can create those beans automatically.<br>At the same time, auto-configuration kicks in through Spring Boot's <span style="background-color: aliceblue;">@EnableAutoConfiguration</span> annotation, which is responsible for automatically configuring beans based on the libraries present on the classpath. Spring Boot inspects the project's dependencies and, using a set of predefined configuration classes, determines which configurations should be applied. For example, if your project includes spring-boot-starter-web, Spring Boot detects the presence of web-related libraries (such as Spring MVC) and configures an embedded Tomcat server by default. On the other hand, if spring-boot-starter-webflux is found, Spring Boot automatically configures a reactive application setup, including an embedded Netty server. These configurations are managed by a combination of conditional annotations, like <span style="background-color: aliceblue;">@ConditionalOnClass</span>, <span style="background-color: aliceblue;">@ConditionalOnMissingBean</span>, and others, ensuring that only the necessary beans are created for the selected dependencies. This decision is entirely based on the dependencies in your classpath, allowing Spring Boot to manage the infrastructure setup with minimal manual intervention.<br>After creating your beans and setting up the server, Spring Boot performs dependency injection, applies any configurations, and runs any CommandLineRunner or ApplicationRunner beans you may have created. When everything is ready, it starts the embedded server so that the application is accessible on the configured port. Finally, it records the end time, calculates how long startup took, and prints a message like <q>Started DemoApplication in X seconds</q>.<br>The method then returns the <span style="background-color: #e4e4e4;">ApplicationContext</span>, although you rarely need to use it directly.</p>
    <p style="margin-top: 8px;">In simple terms, <span style="background-color: #e4e4e4;">SpringApplication.run()</span> is responsible for preparing the environment, loading the banner, creating the Spring container, scanning components, applying auto-configuration, choosing and starting the correct embedded server, running startup logic, and finally launching your application.</p>
    <p class="question">How to speedup the startup time of your spring boot app?</p>
    <p class="answer" style="margin-bottom: 0px;">A slow Spring Boot startup usually happens because the application is doing too much work during the boot phase. Spring creates many beans, applies many auto-configurations, initializes the embedded server, scans large packages, and sometimes performs heavy tasks inside <span style="background-color: aliceblue;">@PostConstruct</span> or runners. The goal is to reduce the amount of work happening before the app becomes available and move anything non-critical to after the application has started.
        <ul style="margin: 0px;">
            <li>Reduce the component-scan area by keeping your main class at a clean root package and avoiding scanning outside packages. The smaller the scan area, the fewer beans Spring has to detect and create, which speeds up startup.</li>
            <li>Remove unused dependencies because Spring Boot auto-configures anything it finds on the classpath. An unnecessary starter means unnecessary configuration, unnecessary beans, and unnecessary time spent during boot.</li>
            <li>Exclude heavy auto-configurations such as JPA, DataSource, or Security when you do not need Spring Boot's default setup. Excluding them does not mean you lose database or security support. It only means Spring Boot will not configure them automatically. You can still configure your DataSource manually, create only the repositories you need, or write a minimal security configuration yourself. The advantage is that you avoid Hibernate initialization, entity scanning, schema validation, default security filters, and many other costly steps that slow down startup.</li>
            <li>Enable lazy initialization so beans are created only when they are needed instead of during startup. This makes the application start quickly, although the first request to a lazy bean may take slightly longer.</li>
            <li>Move heavy initialization tasks such as cache loading, file parsing, or external service calls out of <span style="background-color: #e4e4e4;">@PostConstruct</span> or startup runners and run them after <span style="background-color: aliceblue;">ApplicationReadyEvent</span>. ApplicationReadyEvent fires when the application is completely started, the ApplicationContext is fully initialized, and the embedded server is up. By doing heavy work after this event, your application becomes available much faster because slow operations no longer block the startup process.</li>
            <li>Disable Spring DevTools or development-only tools in production because they slow down bootstrap, classpath scanning, and restart logic.</li>
            <li>Choose the right embedded server for your requirements. Tomcat is default, but some applications see faster startup with Jetty or Undertow depending on their workload and library footprint.</li>
            <li>Use Spring Boot's startup actuator endpoint or tools like Java Flight Recorder to understand exactly which beans or auto-configurations are taking the most time. Once identified, you can optimize or remove them.</li>
            <div class="container" style="margin-top: 0px;">
            <div class="code-block" style="margin: 0px;"><p style="text-align: justify;">This combination of reducing unnecessary auto-configuration, keeping the classpath clean, delaying heavy tasks until ApplicationReadyEvent, and avoiding unnecessary bean creation gives you full control over your startup performance. It ensures the application becomes ready quickly while still allowing you to manually configure any features like database access or security in a lightweight, efficient way.</p></div>
            <pre class="code-block" style="margin: 0px;"><code class="language-java" style="border-radius: 10px;">@Component
public class AppHandler {
    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationEvent() {
        System.out.println(&quot;Application Ready!&quot;);
    }
}</code></pre>
        </div>
        </ul></p>
    <p class="question">How would you speed up a slow-performing API?</p>
    <p class="answer">When an API in a Spring Boot application responds slowly, the goal is to reduce the amount of work the server does for each request and to optimize everything that sits between the request coming in and the response going out. The overall approach is to identify where the delay actually happens and then remove unnecessary processing, reduce heavy operations, improve data access, and use faster execution paths.<br>One common cause of slow responses is heavy database operations. If your API hits the database on every request, the response will only be as fast as the query. Improving this often means optimizing SQL queries, creating proper indexes, using pagination, avoiding N+1 queries, and reducing the amount of data fetched. Using caching for frequently requested data can make responses nearly instant because the app does not have to hit the database at all for repeated calls.<br>Sometimes the business logic in the service layer is doing too much work—parsing large files, performing expensive computations, calling external APIs, or running loops that can be simplified. You can improve response time by breaking heavy logic into smaller pieces, precomputing results when possible, or moving expensive work to background threads so the API can respond immediately and finish work asynchronously if that fits the use case.<br>External API calls are also a major reason for slow responses. If your API depends on another service, you have no control over that service's speed. In such cases, adding timeouts, retries, caching responses, or using asynchronous and non-blocking communication helps prevent your API from waiting unnecessarily. Tools like WebClient in Spring WebFlux or CompletableFuture in Spring MVC can help avoid blocking threads while waiting for external responses.<br>If your service processes large JSON payloads or returns very large responses, serialization and deserialization can slow things down. Reducing payload size, avoiding unnecessary data in responses, and using more efficient serializers can help. Turning off features like Jackson's default reflection-based configuration and customizing object mappers also improves performance.<br>Your API may also be slow because too many requests hit the same service at once. This becomes a concurrency bottleneck where the server is overloaded. Scaling the application horizontally, increasing the thread pool sizes, using connection pooling correctly, and ensuring that beans are stateless can allow the app to handle more requests efficiently. In some cases, using a reactive programming model like WebFlux helps because it handles high concurrency with fewer threads<br>Filters, interceptors, loggers, or AOP aspects can also slow down requests if they perform heavy work, log too much, or serialize large objects. Reviewing these layers and removing unnecessary processing often results in a noticeable improvement. Similarly, enabling compression at the server level, using GZIP for responses, and keeping HTTP headers lightweight helps reduce network overhead.<br>Finally, using performance monitoring tools such as Spring Boot Actuator, Micrometer, Prometheus, or Java Flight Recorder helps you see exactly where the delay is happening. Once you know where the bottleneck is—database, CPU, external service, serialization, or network—you can apply the right optimization rather than guessing.</p>







        <script>
        hljs.highlightAll(); 
    </script>
    </body>
</html>